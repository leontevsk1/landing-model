# Модель демонстрирующая работу решения в режиме посадки

## Цель

Смоделировать посадку БПЛА по сигналам с маяка

## Принцип реализации

### БПЛА

- моделируется как **точка** на плоскости;

- имеет **направленную антенну** (угол приёма ≈ 45°);

- управляется в трех координатах;

- логика полёта — **наш адаптированный курсово-глиссадный алгоритм**.

### Маяк

- моделируется как **точка** с восемью секторами излучения по 45°;

- активирует сектора **поочерёдно**;

- вычисляет и передаёт мощность сигнала в направлении на БПЛА.

### Сценарии

- отдельный модуль для параметров (ветер, шум, стартовые координаты);

- реализуем **в последнюю очередь**;

- если не успеваем — описываем логику и оставляем заглушки.

### Визуализация

- плоская 2D-анимация: маяк, сектора, траектория БПЛА;

- matplotlib / FuncAnimation (или аналог);

- вывод в `.gif` / `.mp4` для презентации.


## Структура

### Тут пишем общую структуру и документируем функции чтобы быстрее понимать что делать в задачах

**Базовая структура проекта:**

```bash
.
├──.git
├──.gitignore 
├── environment.lock.yml - конфиг окружения
├── README.md
├── export_data/ - директория для экспорта анимаций
├── src/
│   ├── classes.py- логика классов
│   ├── main.py   - посадка в идеале
│   ├── scenes.py - сценарии посадки
│   └── visual.py - визуализация
└── как-ведем-гит.md
```

# Документация: `classes.py`

## Константы диаграммы

* `N = 8` — число секторов.
* `STEP = π/4` — шаг по азимуту между осями секторов.
* `WIDTH = 60°` — полная ширина лепестка (в радианах).
* `POWER = 15.0` — мощность маяка по умолчанию (Вт).

## Вспомогательные функции

* `axis_unit(i: int) -> np.ndarray`: единичный 3D-вектор оси сектора `i` (yaw кратен `STEP`, небольшой «наклон» по pitch для модели).
* `energy_flux(R: float, alpha: float, w: float, P: float) -> float`: плотность потока (Вт/м²) на расстоянии `R` под углом отклонения `alpha` внутри диаграммы ширины `w` от источника мощности `P`. Угасание ~ `1/R²`, внутри лепестка — квадратичный профиль, вне — 0.

## Класс `Beacon`

Точечный направленный излучатель.

* Поля:

  * `pos: np.ndarray` — позиция `[x, y, z]`;
  * `sector_id: int` — активный сектор (0..7);
  * `power_w: float` — мощность маяка (Вт);
  * `width_rad: float` — ширина лепестка (рад).
* Методы:

  * `set_sector(i: int)`: сделать активным сектор `i % N`.

## Класс `Environment`

Агрегирует вклад всех маяков в заданной точке.

* Конструктор: `Environment(beacons: list[Beacon])`.
* `power_lin_at(pos: np.ndarray) -> list[float, int]`: возвращает `[total_power, sector_id]`, где `total_power` — суммарная мощность от **всех** маяков в `pos`, а `sector_id` — текущий сектор **последнего обработанного** маяка (текущее поведение модели; если нужен иной семантический смысл, меняйте интерфейс).

## Класс `Drone`

Простейшая кинематика точки с направлением и скоростью.

* Поля:

  * `pos: np.ndarray` — позиция `[x, y, z]`;
  * `direction: np.ndarray` — единичный вектор направления;
  * `speed: float` — скалярная скорость (м/с);
  * `landing_power: float`, `safe_power: float`, `landing_flag: bool` — задел под логику посадки.
* Методы:

  * `measure_flux(env: Environment) -> list[float, int]`: измерение потока в текущей позиции; возвращает `[мощность, active_sector_id]`.
  * `change_altitude_rate(delta_pitch_rad: float)`: изменить тангаж (вертикальный угол направления).
  * `change_speed(delta_v: float)`: изменить скалярную скорость (не отрицательная).
  * `change_yaw(delta_yaw_rad: float)`: повернуть курс в плоскости XY (рысканье).
  * `_update_kinematics(dt: float)`: шаг интеграции `pos += (speed * direction) * dt`.

**Мини-пример**

```python
from classes import Beacon, Environment, Drone
b = Beacon()
e = Environment([b])
d = Drone(10.0, 1.0, 3.0)

b.set_sector(0)     # ось ≈ +X
print(d.measure_flux(e))  # -> [power, sector_id]
```

---

# Документация: `scenes.py`

Набор утилит и сценариев проверки кинематики дрона.

## Хелперы

* `vec_to_deg(v: np.ndarray) -> float`: yaw (в градусах) для вектора `[x, y]`.
* `vec_to_pitch_deg(v: np.ndarray) -> float`: pitch (в градусах) для 3D-вектора относительно плоскости XY.

## Сценарий-тест

* `test_drone_kinematics()`: последовательная проверка:

  1. изменение скорости и корректный шаг `_update_kinematics(dt)`;
  2. поворот на +90° (yaw) и смещение по Y;
  3. снижение на −45° (pitch) и корректное изменение координаты `Z`.
     Используются `assert` для валидации результатов; в конце печатает успех.

**Запуск**

```bash
python scenes.py
```

---

# Документация: `visual.py`

2D-визуализация TDM-маяка и траектории дрона (Matplotlib + FuncAnimation).

## Константы

* `FRAME_RATE = 100` — общее число кадров (для анимации).
* `TIME_STEP = 0.1` — шаг симуляции `dt` (сек).
* `SECTORS_PER_FRAME = 10` — длительность «включения» сектора (кол-во кадров на сектор); полный TDM-цикл: `N * SECTORS_PER_FRAME`.

## Ключевые функции

* `get_sector_patch(beacon_pos, sector_id, color) -> patches.Wedge`: клин сектора на плане XY для текущего `sector_id`.
* `setup_scene(beacon) -> (fig, ax, sector_patch, line, point)`: создаёт сцену, добавляет маяк, активный сектор, линию траектории и маркер дрона.
* `animate(frame, beacon, drone, env, sector_patch, line, point, trajectory_data)`:

  * циклически переключает `beacon.sector_id`;
  * вносит малые случайные команды (`change_yaw`, `change_speed`, `change_altitude_rate`);
  * вызывает `drone._update_kinematics(TIME_STEP)`;
  * измеряет поток `drone.measure_flux(env)`;
  * обновляет линию траектории и точку дрона; периодически логирует кадр/сектор/мощность/позицию.

## Использование

```bash
python visual.py
```

Откроется окно matplotlib с видом сверху: маяк в (0,0), подсветка активного сектора, траектория и текущая позиция дрона. В консоли — телеметрия каждые ~50 кадров.

**Примечания**

* Для сценариев посадки замените случайные команды управления на детерминированную логику (курс/глиссада/порог по `landing_power` и т.п.).
* При необходимости добавьте запись анимации (`FuncAnimation.save`) и/или экспорт телеметрии.

---